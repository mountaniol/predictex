# Руководство по настройке и использованию системы веб-поиска

## Обзор

Система веб-поиска предоставляет AI моделям возможность получать актуальную информацию из интернета без использования платных API. Система автоматически определяет, когда нужна информация из интернета, и выбирает оптимальные источники данных.

## Быстрый старт

### 1. Установка зависимостей

```bash
pip install -r requirements.txt
```

Это установит необходимые пакеты:
- `aiohttp` - для асинхронных HTTP запросов
- `feedparser` - для парсинга RSS лент
- `beautifulsoup4` - для парсинга HTML контента
- `lxml` - парсер для BeautifulSoup
- `python-dateutil` - для работы с датами

### 2. Включение веб-поиска

Веб-поиск уже настроен в `public/app.config.json`. Убедитесь, что секция `web_search` включена:

```json
{
  "Backend": {
    "web_search": {
      "enabled": true,
      ...
    }
  }
}
```

### 3. Проверка работы

После запуска backend сервера, AI модель автоматически будет использовать веб-поиск при необходимости.

## Конфигурация

### Основные параметры

В файле `public/app.config.json`:

```json
{
  "Backend": {
    "web_search": {
      "enabled": true,                    // Включить/выключить веб-поиск
      "default_language": "ru",           // Язык по умолчанию
      "max_results": 10,                  // Максимальное количество результатов
      "timeout": 30,                      // Таймаут для поиска (секунды)
      "strategy": "smart_routing",        // Стратегия выбора провайдеров
      
      "classification": {
        "confidence_threshold": 0.7,      // Порог уверенности классификатора
        "fallback_strategy": "all_providers"  // Стратегия при низкой уверенности
      }
    }
  }
}
```

### Настройка провайдеров

#### DuckDuckGo (общий веб-поиск)
```json
"duckduckgo": {
  "enabled": true,
  "weight": 0.7,                          // Вес для ранжирования результатов
  "base_url": "https://api.duckduckgo.com/",
  "safe_search": "moderate",              // off, moderate, strict
  "region": "ru-ru",                      // Регион поиска
  "timeout": 20
}
```

#### Wikipedia (энциклопедические данные)
```json
"wikipedia": {
  "enabled": true,
  "weight": 0.9,
  "language": "ru",                       // Основной язык
  "fallback_languages": ["en"],          // Резервные языки
  "max_summary_length": 1000,             // Максимальная длина выдержки
  "include_images": false,                // Включать изображения
  "timeout": 15
}
```

#### RSS (новости и актуальная информация)
```json
"rss": {
  "enabled": true,
  "weight": 0.8,
  "cache_duration": 3600,                 // Время кэширования RSS (секунды)
  "timeout": 20,
  "feeds": {
    "news": [                             // Новостные ленты
      "https://rss.rbc.ru/rbcnews/news.rss",
      "https://tass.ru/rss/v2.xml"
    ],
    "tech": [                             // Технологические новости
      "https://habr.com/ru/rss/hub/programming/all/"
    ],
    "business": [                         // Бизнес новости
      "https://www.vedomosti.ru/rss/news"
    ]
  }
}
```

### Настройка кэширования

```json
"cache": {
  "enabled": true,
  "db_path": "data/search_cache.db",     // Путь к базе данных кэша
  "default_ttl": 3600,                    // Время жизни кэша по умолчанию
  "max_entries": 10000,                   // Максимальное количество записей
  "cleanup_interval": 3600                // Интервал очистки кэша
}
```

### Настройка Rate Limiting

```json
"rate_limiting": {
  "enabled": true,
  "requests_per_minute": 60,              // Лимит запросов в минуту
  "requests_per_hour": 1000,              // Лимит запросов в час
  "burst_size": 10                        // Размер пакета запросов
}
```

### Интеграция с AI моделями

```json
"ai_web_search_integration": {
  "enabled": true,
  "auto_search_triggers": [               // Триггеры для автоматического поиска
    "найди",
    "поищи", 
    "актуальная информация",
    "последние новости",
    "что происходит"
  ],
  "max_search_results_in_context": 5,     // Макс. результатов в контексте AI
  "search_result_format": "markdown"       // Формат результатов (markdown/plain)
}
```

## Типы запросов и их обработка

### 1. Фактические запросы (factual)
Для вопросов типа "Что такое...", "Кто такой..." используется Wikipedia.

**Пример:** "Что такое машинное обучение?"
- Основной источник: Wikipedia
- Резервный: DuckDuckGo

### 2. Актуальные запросы (current)
Для новостей и текущих событий используются RSS ленты и DuckDuckGo.

**Пример:** "Какие новости сегодня в технологиях?"
- Основной источник: RSS feeds
- Дополнительный: DuckDuckGo

### 3. Общие запросы (general)
Для остальных запросов используется DuckDuckGo.

**Пример:** "Найди информацию о лучших практиках Python"
- Основной источник: DuckDuckGo
- Дополнительный: Wikipedia

## Добавление новых RSS источников

1. Откройте `public/app.config.json`
2. Найдите секцию `rss.feeds`
3. Добавьте новую категорию или URL в существующую:

```json
"rss": {
  "feeds": {
    "custom_category": [
      "https://your-rss-feed.com/rss"
    ]
  }
}
```

## Отладка и мониторинг

### Логирование

Система автоматически логирует:
- Классификацию запросов
- Выбранные провайдеры
- Результаты поиска
- Ошибки и предупреждения

### Проверка статуса провайдеров

```python
# В коде можно проверить доступность провайдеров:
from src.backend.search_router import SearchRouter

router = SearchRouter(config['Backend']['web_search'])
status = await router.health_check()
print(status)
```

### Статистика кэша

Кэш автоматически сохраняет статистику использования:
- Количество записей
- Процент попаданий
- Популярные запросы

## Оптимизация производительности

### 1. Настройка кэша
- Увеличьте `max_entries` для больших проектов
- Настройте TTL в зависимости от типа контента:
  - Новости: 1 час
  - Факты: 24 часа
  - Общая информация: 6 часов

### 2. Выбор провайдеров
- Отключите неиспользуемые провайдеры
- Настройте веса для приоритизации источников

### 3. RSS оптимизация
- Удалите медленные или нерелевантные RSS ленты
- Увеличьте `cache_duration` для стабильных источников

## Частые проблемы и решения

### Проблема: Поиск не возвращает результаты

**Решение:**
1. Проверьте, что `web_search.enabled = true`
2. Убедитесь, что провайдеры доступны
3. Проверьте интернет-соединение

### Проблема: Медленный поиск

**Решение:**
1. Уменьшите `max_results`
2. Увеличьте кэширование
3. Отключите медленные провайдеры

### Проблема: Нерелевантные результаты

**Решение:**
1. Настройте `confidence_threshold`
2. Добавьте более специфичные RSS источники
3. Настройте веса провайдеров

## Примеры использования

### Пример 1: Вопрос о текущих событиях
```
Пользователь: "Какие последние новости в мире технологий?"
```
Система:
1. Классифицирует как "current"
2. Использует RSS провайдер (tech feeds)
3. Дополняет результатами из DuckDuckGo
4. AI получает актуальную информацию и формирует ответ

### Пример 2: Фактический вопрос
```
Пользователь: "Что такое нейронные сети?"
```
Система:
1. Классифицирует как "factual"
2. Ищет в Wikipedia
3. При необходимости дополняет из DuckDuckGo
4. AI использует найденную информацию для объяснения

### Пример 3: Смешанный запрос
```
Пользователь: "Найди информацию о последних достижениях в области ИИ"
```
Система:
1. Классифицирует как "mixed" (factual + current)
2. Использует все доступные провайдеры
3. Агрегирует результаты
4. AI синтезирует ответ из разных источников

## Безопасность и этика

### Rate Limiting
- Система автоматически ограничивает количество запросов
- Соблюдаются лимиты внешних сервисов

### Фильтрация контента
- Используется безопасный поиск DuckDuckGo
- Фильтруются дубликаты результатов

### Атрибуция источников
- Все результаты содержат ссылки на источники
- AI указывает, откуда получена информация

## Расширение системы

### Добавление нового провайдера

1. Создайте класс, наследующий `SearchProvider`
2. Реализуйте методы `search()` и `is_available()`
3. Добавьте провайдер в `SearchRouter`
4. Обновите конфигурацию

### Пример кастомного провайдера:
```python
from src.backend.search_providers import SearchProvider

class CustomProvider(SearchProvider):
    async def search(self, query: SearchQuery) -> List[SearchResult]:
        # Ваша логика поиска
        pass
        
    def is_available(self) -> bool:
        # Проверка доступности
        return True
        
    def get_supported_query_types(self) -> List[str]:
        return ["custom_type"]
```

## Заключение

Система веб-поиска предоставляет мощный инструмент для обогащения ответов AI актуальной информацией. При правильной настройке она работает автоматически и прозрачно для пользователя, значительно улучшая качество ответов на вопросы, требующие актуальных данных.